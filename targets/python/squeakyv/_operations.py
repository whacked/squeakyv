"""
Auto-generated SQLite operations for squeakyv.
DO NOT EDIT THIS FILE MANUALLY - it is generated by the build pipeline.
Source: generators/languages/python.py
"""
import sqlite3

DEBUG_LEVEL = 0


# Embedded database schema
SCHEMA_SQL = """
/*
 * Table: __metadata__
 * Description: Database internal metadata table
 */
CREATE TABLE IF NOT EXISTS __metadata__ (
  -- Metadata key (e.g., 'schema_version', 'creation_date')
  key TEXT NOT NULL PRIMARY KEY,
  -- Associated value for the metadata key
  value TEXT NOT NULL
);

/*
 * Table: kv
 * Description: Single key-value table storing arbitrary values
 */
CREATE TABLE IF NOT EXISTS kv (
  -- UNIX insertion time (milliseconds)
  inserted_at INTEGER NOT NULL DEFAULT (CAST(unixepoch('subsec') * 1000 AS INTEGER)),
  -- Logical active flag (0 or 1)
  is_active INTEGER NOT NULL DEFAULT (1) CHECK (is_active IN (0,1)),
  -- Logical key identifier
  key TEXT NOT NULL,
  -- Arbitrary payload stored as BLOB for maximum compatibility
  value BLOB NOT NULL
);


/*
 * Initialization Data: Schema Version and Creation Date (Idempotent)
 * These records are only inserted if they do not already exist.
 */
INSERT OR IGNORE INTO __metadata__ (key, value) VALUES ('schema_version', '1.0.0');
INSERT OR IGNORE INTO __metadata__ (key, value) VALUES ('schema_tree_ish', 'git-hash-abc123');
INSERT OR IGNORE INTO __metadata__ (key, value) VALUES ('creation_date', strftime('%Y-%m-%dT%H:%M:%f', 'now'));

-- Only one active row per key
CREATE UNIQUE INDEX IF NOT EXISTS kv_active_key ON kv(key) WHERE is_active = 1;

-- Time-travel and scans
CREATE INDEX IF NOT EXISTS kv_key_time ON kv(key, inserted_at);

-- Swap-out on overwrite: retire old active row just before insert
CREATE TRIGGER IF NOT EXISTS kv_swap_active
BEFORE INSERT ON kv
FOR EACH ROW
BEGIN
  UPDATE kv SET is_active = 0
  WHERE key = NEW.key AND is_active = 1;
END;

-- Convenience view
CREATE VIEW IF NOT EXISTS kv_current AS
  SELECT key, value, inserted_at
  FROM kv
  WHERE is_active = 1;


"""


def _delete_key(conn: sqlite3.Connection, key) -> None:
    """Execute delete_key query, returns None"""
    statement = """UPDATE kv
SET is_active = 0
WHERE key = :key AND is_active = 1;
"""
    parameters = {"key": key}
    if DEBUG_LEVEL > 0:
        print("STATEMENT:", statement)
        print("PARAMETERS:", parameters)
    cursor = conn.execute(statement, parameters)

    return None


def _get_current_value(conn: sqlite3.Connection, key) -> str | bytes | None:
    """Execute get_current_value query, returns str | bytes | None"""
    statement = """SELECT value -- , inserted_at
FROM kv
WHERE key = :key AND is_active = 1;
"""
    parameters = {"key": key}
    if DEBUG_LEVEL > 0:
        print("STATEMENT:", statement)
        print("PARAMETERS:", parameters)
    cursor = conn.execute(statement, parameters)

    return (row[0] if (row := cursor.fetchone()) is not None else None)


def _list_active_keys(conn: sqlite3.Connection, ) -> list[str]:
    """Execute list_active_keys query, returns list[str]"""
    statement = """SELECT key -- , inserted_at
FROM kv
WHERE is_active = 1
ORDER BY inserted_at DESC;
"""
    parameters = {}
    if DEBUG_LEVEL > 0:
        print("STATEMENT:", statement)
        print("PARAMETERS:", parameters)
    cursor = conn.execute(statement, parameters)

    return [row[0] for row in cursor.fetchall()]


def _set_value(conn: sqlite3.Connection, key, value) -> None:
    """Execute set_value query, returns None"""
    statement = """INSERT INTO kv (key, value)
VALUES (:key, :value);
"""
    parameters = {"key": key, "value": value}
    if DEBUG_LEVEL > 0:
        print("STATEMENT:", statement)
        print("PARAMETERS:", parameters)
    cursor = conn.execute(statement, parameters)

    return None
