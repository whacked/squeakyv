from dataclasses import dataclass
from typing import Dict, Optional

import jinja2
from aiosql.types import QueryFn, SQLOperationType


def render(statements_map: Dict[str, QueryFn], schema_sql: Optional[str] = None) -> str:
    out: list[str] = []

    # Header
    out.append('''\
;;; squeakyv.el --- Simple SQLite-backed cache -*- lexical-binding: t -*-

;; Author: squeakyv contributors
;; Version: 0.1.0
;; Package-Requires: ((emacs "29.1"))
;; Keywords: cache, sqlite, database
;; URL: https://github.com/squeakyv/squeakyv

;;; Commentary:

;; squeakyv provides a simple SQLite-backed key-value cache for Emacs.
;; Requires Emacs 29.1+ with built-in SQLite support.
;;
;; Basic usage:
;;
;;   (require 'sqlite)
;;   (setq db (sqlite-open "cache.db"))
;;   (squeakyv-init-db db)
;;   (squeakyv-set-value db "key" "value")
;;   (squeakyv-get-current-value db "key")
;;
;; Auto-generated by squeakyv build pipeline. DO NOT EDIT.

;;; Code:

(require 'sqlite)

''')

    # Parse schema SQL and generate init function
    if schema_sql:
        # Parse SQL into individual statements
        def parse_sql_statements(sql: str) -> list[str]:
            """Parse SQL into individual statements, handling multi-line constructs."""
            statements = []
            current = []
            in_trigger = False
            in_block_comment = False

            for line in sql.split('\n'):
                stripped = line.strip()

                # Handle block comments
                if '/*' in line:
                    in_block_comment = True
                if '*/' in line:
                    in_block_comment = False
                    continue

                # Skip if we're in a block comment
                if in_block_comment:
                    continue

                # Skip empty lines and line comments
                if not stripped or stripped.startswith('--'):
                    continue

                current.append(line)

                # Track if we're in a trigger (BEGIN...END construct)
                if 'CREATE TRIGGER' in line.upper():
                    in_trigger = True

                # Statement ends at semicolon, unless we're in a trigger waiting for END
                if ';' in line:
                    if in_trigger and 'END' in line.upper():
                        in_trigger = False
                        statements.append('\n'.join(current))
                        current = []
                    elif not in_trigger:
                        statements.append('\n'.join(current))
                        current = []

            return statements

        statements = parse_sql_statements(schema_sql)

        # Generate init function with parsed statements
        out.append('(defun squeakyv-init-db (db)\n')
        out.append('  "Initialize database schema in DB.\n')
        out.append('DB should be a SQLite database handle from `sqlite-open\'."\n')
        out.append('  ;; Auto-generated schema initialization\n')

        for stmt in statements:
            # Clean up the statement
            clean_stmt = ' '.join(stmt.split())  # Collapse whitespace
            # Escape for Elisp string
            escaped_stmt = clean_stmt.replace('\\', '\\\\').replace('"', '\\"')
            out.append(f'  (sqlite-execute db "{escaped_stmt}")\n')

        out.append('  nil)\n\n')
    else:
        # Fallback if no schema provided
        out.append('''\
(defun squeakyv-init-db (db)
  "Initialize database schema in DB."
  (error "No schema SQL provided during code generation"))

''')

    # Generate functions from YeSQL queries
    @dataclass
    class FunctionInfo:
        function_name: str
        execution_type: str  # "execute" or "select"
        returns_one: bool

    def snake_to_kebab(name: str) -> str:
        """Convert snake_case to kebab-case."""
        return name.replace('_', '-')

    def get_function_info(fname: str, operation: SQLOperationType) -> FunctionInfo:
        """Determine Elisp function name and execution type."""
        func_name = "squeakyv-" + snake_to_kebab(fname.replace('-', '_'))

        if operation == SQLOperationType.SELECT_ONE:
            return FunctionInfo(
                function_name=func_name,
                execution_type="select",
                returns_one=True
            )
        elif operation == SQLOperationType.SELECT:
            return FunctionInfo(
                function_name=func_name,
                execution_type="select",
                returns_one=False
            )
        else:
            return FunctionInfo(
                function_name=func_name,
                execution_type="execute",
                returns_one=False
            )

    # Convert named parameters to positional for SQLite
    def convert_to_positional_sql(sql: str, params: list[str]) -> str:
        """Convert :param syntax to ? placeholders."""
        result = sql
        for param in params:
            result = result.replace(f":{param}", "?")
        return result

    FUNCTION_TEMPLATE = jinja2.Template('''\
(defun {{ function_name }} (db{{ param_list }})
  "{{ docstring }}"
  (let ((sql "{{ sql }}")
        (params (list{{ params }})))
{% if execution_type == "select" %}{% if returns_one %}    ;; Return first value from first row, or nil
    (let ((result (sqlite-select db sql params)))
      (if result
          (car (car result))
        nil)){% else %}    ;; Return list of values (first column from each row)
    (mapcar #'car (sqlite-select db sql params)){% endif %}{% else %}    (sqlite-execute db sql params)
    nil{% endif %}))
''')

    for fname, qfn in statements_map.items():
        func_info = get_function_info(fname, qfn.operation)

        # Build parameter list
        param_list = ""
        params = ""
        for param in qfn.parameters:
            param_list += f" {snake_to_kebab(param)}"
            params += f" {snake_to_kebab(param)}"

        # Convert SQL to positional parameters
        positional_sql = convert_to_positional_sql(qfn.sql.strip(), qfn.parameters)

        # Escape SQL for Elisp string
        escaped_sql = positional_sql.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n')

        out.append(
            FUNCTION_TEMPLATE.render(
                function_name=func_info.function_name,
                param_list=param_list,
                params=params,
                sql=escaped_sql,
                docstring=f"Execute {fname} operation.",
                execution_type=func_info.execution_type,
                returns_one=func_info.returns_one
            ).rstrip()
        )
        out.append("\n")

    # Footer
    out.append('''\
(provide 'squeakyv)
;;; squeakyv.el ends here
''')

    return "\n".join(out)
