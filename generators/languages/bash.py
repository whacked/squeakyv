from dataclasses import dataclass
from typing import Dict, Optional

import jinja2
from aiosql.types import QueryFn, SQLOperationType


def render(statements_map: Dict[str, QueryFn], schema_sql: Optional[str] = None) -> str:
    out: list[str] = []

    # Header
    out.append('''\
#!/usr/bin/env bash
# Auto-generated SQLite operations for squeakyv (Bash)
# DO NOT EDIT THIS FILE MANUALLY - it is generated by the build pipeline.
# Source: generators/languages/bash.py

set -euo pipefail

SQUEAKYV_DEBUG="${SQUEAKYV_DEBUG:-0}"

''')

    # Embed schema SQL if provided
    if schema_sql:
        # Escape for bash heredoc (just need to escape $, `, \, and !)
        escaped_sql = schema_sql.replace('\\', '\\\\').replace('$', '\\$').replace('`', '\\`')
        out.append(f'''# Embedded database schema
SQUEAKYV_SCHEMA_SQL=$(cat <<'SQUEAKYV_SCHEMA_EOF'
{escaped_sql}
SQUEAKYV_SCHEMA_EOF
)

''')

    # Helper function to execute SQL with parameters
    out.append('''\
# Internal: Execute parameterized SQL query
# Args: db_path, sql, param_name1, param_value1, param_name2, param_value2, ...
_squeakyv_execute() {
    local db_path="$1"
    local sql="$2"
    shift 2

    local sqlite_input="$sql"

    # Build parameter assignments
    while [[ $# -gt 0 ]]; do
        local param_name="$1"
        local param_value="$2"
        shift 2

        # SQLite CLI parameter binding (before the SQL statement)
        sqlite_input=".param set :${param_name} '${param_value}'
${sqlite_input}"
    done

    if [[ "$SQUEAKYV_DEBUG" -gt 0 ]]; then
        echo "[DEBUG] SQL: $sql" >&2
        echo "[DEBUG] Input: $sqlite_input" >&2
    fi

    echo "$sqlite_input" | sqlite3 "$db_path"
}

# Internal: Execute SQL query and return single value
_squeakyv_query_one() {
    local db_path="$1"
    local sql="$2"
    shift 2

    local sqlite_input="$sql"

    while [[ $# -gt 0 ]]; do
        local param_name="$1"
        local param_value="$2"
        shift 2
        sqlite_input=".param set :${param_name} '${param_value}'
${sqlite_input}"
    done

    if [[ "$SQUEAKYV_DEBUG" -gt 0 ]]; then
        echo "[DEBUG] SQL: $sql" >&2
    fi

    echo "$sqlite_input" | sqlite3 "$db_path"
}

# Internal: Execute SQL query and return multiple rows
_squeakyv_query_all() {
    local db_path="$1"
    local sql="$2"
    shift 2

    local sqlite_input="$sql"

    while [[ $# -gt 0 ]]; do
        local param_name="$1"
        local param_value="$2"
        shift 2
        sqlite_input=".param set :${param_name} '${param_value}'
${sqlite_input}"
    done

    if [[ "$SQUEAKYV_DEBUG" -gt 0 ]]; then
        echo "[DEBUG] SQL: $sql" >&2
    fi

    echo "$sqlite_input" | sqlite3 "$db_path"
}

# Initialize database schema
squeakyv_init_db() {
    local db_path="$1"

    if [[ -z "${SQUEAKYV_SCHEMA_SQL:-}" ]]; then
        echo "Error: SQUEAKYV_SCHEMA_SQL not defined" >&2
        return 1
    fi

    echo "$SQUEAKYV_SCHEMA_SQL" | sqlite3 "$db_path"
}

''')

    # Generate functions from YeSQL queries
    @dataclass
    class FunctionInfo:
        bash_func_name: str
        execution_type: str  # "execute", "query_one", "query_all"

    def get_function_info(fname: str, operation: SQLOperationType) -> FunctionInfo:
        """Determine bash function name and execution type."""
        # Convert hyphenated names to underscored
        bash_name = fname.replace('-', '_')

        if operation == SQLOperationType.SELECT_ONE:
            return FunctionInfo(
                bash_func_name=bash_name,
                execution_type="query_one"
            )
        elif operation == SQLOperationType.SELECT:
            return FunctionInfo(
                bash_func_name=bash_name,
                execution_type="query_all"
            )
        else:
            return FunctionInfo(
                bash_func_name=bash_name,
                execution_type="execute"
            )

    FUNCTION_TEMPLATE = jinja2.Template('''\
# {{ docstring }}
squeakyv_{{ bash_func_name }}() {
    local db_path="$1"
{%- for param in parameters %}
    local {{ param }}="${{ loop.index + 1 }}"
{%- endfor %}

    local sql=$(cat <<'SQUEAKYV_SQL_EOF'
{{ sql }}
SQUEAKYV_SQL_EOF
)

    _squeakyv_{{ execution_type }} "$db_path" "$sql"{% for param in parameters %} "{{ param }}" "${{ param }}"{% endfor %}
}
''')

    for fname, qfn in statements_map.items():
        func_info = get_function_info(fname, qfn.operation)

        out.append(
            FUNCTION_TEMPLATE.render(
                bash_func_name=func_info.bash_func_name,
                parameters=qfn.parameters,
                sql=qfn.sql.strip(),
                docstring=f"Execute {fname} operation",
                execution_type=func_info.execution_type
            ).rstrip()
        )
        out.append("\n")

    return "\n".join(out)
