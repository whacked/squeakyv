from dataclasses import dataclass
from typing import Dict, Optional

import jinja2
from aiosql.types import QueryFn, SQLOperationType


def render(statements_map: Dict[str, QueryFn], schema_sql: Optional[str] = None) -> str:
    out: list[str] = []

    # Package and imports
    out.append('''\
// Code generated by squeakyv build pipeline. DO NOT EDIT.
// Source: generators/languages/go.py

package squeakyv

import (
\t"database/sql"
\t"fmt"
)

''')

    # Embed schema SQL if provided
    if schema_sql:
        # Escape backticks for Go raw string literals
        escaped_sql = schema_sql.replace('`', '` + "`" + `')
        out.append(f'''// SchemaSQL contains the embedded database schema
const SchemaSQL = `{escaped_sql}`

''')

    # Generate functions from YeSQL queries
    @dataclass
    class ReturnInfo:
        return_type: str
        return_signature: str
        implementation: str

    def snake_to_camel(name: str) -> str:
        """Convert snake_case to camelCase (private)."""
        components = name.split('_')
        return components[0] + ''.join(x.title() for x in components[1:])

    def get_return_info(operation: SQLOperationType) -> ReturnInfo:
        """Determine Go return type and implementation based on SQL operation."""
        if operation == SQLOperationType.SELECT_ONE:
            return ReturnInfo(
                return_type="([]byte, error)",
                return_signature="([]byte, error)",
                implementation="""
\tvar value []byte
\terr := db.QueryRow(query, args...).Scan(&value)
\tif err == sql.ErrNoRows {
\t\treturn nil, nil
\t}
\tif err != nil {
\t\treturn nil, fmt.Errorf("query failed: %w", err)
\t}
\treturn value, nil"""
            )
        elif operation == SQLOperationType.SELECT:
            return ReturnInfo(
                return_type="([]string, error)",
                return_signature="([]string, error)",
                implementation="""
\trows, err := db.Query(query, args...)
\tif err != nil {
\t\treturn nil, fmt.Errorf("query failed: %w", err)
\t}
\tdefer rows.Close()

\tvar results []string
\tfor rows.Next() {
\t\tvar value string
\t\tif err := rows.Scan(&value); err != nil {
\t\t\treturn nil, fmt.Errorf("scan failed: %w", err)
\t\t}
\t\tresults = append(results, value)
\t}

\tif err = rows.Err(); err != nil {
\t\treturn nil, fmt.Errorf("rows iteration failed: %w", err)
\t}

\treturn results, nil"""
            )
        else:  # INSERT_UPDATE_DELETE
            return ReturnInfo(
                return_type="error",
                return_signature="error",
                implementation="""
\t_, err := db.Exec(query, args...)
\tif err != nil {
\t\treturn fmt.Errorf("exec failed: %w", err)
\t}
\treturn nil"""
            )

    # Convert named parameters to positional for SQLite
    def convert_to_positional_sql(sql: str, params: list[str]) -> str:
        """Convert :param syntax to ? placeholders."""
        result = sql
        for param in params:
            result = result.replace(f":{param}", "?")
        return result

    FUNCTION_TEMPLATE = jinja2.Template('''\
// {{ funcName }} executes the {{ originalName }} query
func {{ funcName }}(db *sql.DB{{ paramDecls }}) {{ returnSig }} {
\tquery := `{{ sql }}`
{{ argsArray }}
{{ implementation }}
}
''')

    for fname, qfn in statements_map.items():
        return_info = get_return_info(qfn.operation)
        func_name = "_" + snake_to_camel(fname.replace('-', '_'))

        # Build parameter declarations
        param_decls = ""
        for param in qfn.parameters:
            # Determine parameter type (string or []byte for value)
            param_type = "[]byte" if param == "value" else "string"
            param_decls += f", {param} {param_type}"

        # Build args array for positional binding
        if qfn.parameters:
            args_list = ", ".join(qfn.parameters)
            args_array = "\targs := []interface{}{" + args_list + "}"
        else:
            args_array = "\targs := []interface{}{}"

        # Convert SQL to positional parameters
        positional_sql = convert_to_positional_sql(qfn.sql.strip(), qfn.parameters)

        out.append(
            FUNCTION_TEMPLATE.render(
                funcName=func_name,
                originalName=fname,
                paramDecls=param_decls,
                returnSig=return_info.return_signature,
                sql=positional_sql,
                argsArray=args_array,
                implementation=return_info.implementation
            ).rstrip()
        )
        out.append("\n")

    return "\n".join(out)
